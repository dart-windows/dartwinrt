// Copyright (c) 2023, Dart | Windows. Please see the AUTHORS file for details.
// All rights reserved. Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

import 'package:args/args.dart';
import 'package:winrtgen/winrtgen.dart';

Future<void> addEnum(String type) async {
  final typeAnalyzer = TypeAnalyzer.fromType(type);
  if (!typeAnalyzer.isEnum) {
    throw ArgumentError.value(type, 'type', 'Not an enum.');
  }

  final enumManager = EnumManager();
  final assetPath = enumManager.path;

  if (enumManager.contains(type)) {
    throw StateError('`$type` already exists in `$assetPath`.');
  }

  print('Fetching documentation for `$type`...');
  final documentation = await WinRTDocsService.fetchDocumentation(type);
  print('Adding `$type` into `$assetPath`...');
  enumManager.add(type, comment: documentation);
  print('Done!');
}

Future<void> addObject(String type) async {
  final typeAnalyzer = TypeAnalyzer.fromType(type);
  if (!typeAnalyzer.isObject) {
    throw ArgumentError.value(type, 'type', 'Not an object.');
  }

  final objectManager = ObjectManager();
  final assetPath = objectManager.path;

  if (objectManager.contains(type)) {
    throw StateError('`$type` already exists in `$assetPath`.');
  }

  final dependencies = typeAnalyzer.dependencies;
  print(dependencies);

  if (!dependencies.hasNewDependencies) {
    print('No new dependencies found for `$type`.');
    return;
  }

  print('Fetching documentations for the dependencies of `$type`...');
  final docs = await WinRTDocsService.fetchDocumentations({
    ...dependencies.enums,
    ...dependencies.objects,
    ...dependencies.structs
  });

  print('Adding the dependencies into JSON files...');

  if (dependencies.enums.isNotEmpty) {
    final enumManager = EnumManager();
    final assetPath = enumManager.path;
    print(' - Updating `$assetPath`...');
    enumManager.addAll({
      for (final enumType in dependencies.enums) enumType: docs[enumType] ?? ''
    });
  }

  if (dependencies.objects.isNotEmpty) {
    print(' - Updating `$assetPath`...');
    objectManager.addAll({
      for (final object in dependencies.objects) object: docs[object] ?? ''
    });
  }

  if (dependencies.structs.isNotEmpty) {
    final structManager = StructManager();
    final assetPath = structManager.path;
    print(' - Updating `$assetPath`...');
    structManager.addAll({
      for (final struct in dependencies.structs) struct: docs[struct] ?? ''
    });
  }

  print('Done!');
}

Future<void> addStruct(String type) async {
  final typeAnalyzer = TypeAnalyzer.fromType(type);
  if (!typeAnalyzer.isStruct) {
    throw ArgumentError.value(type, 'type', 'Not a struct.');
  }

  final structManager = StructManager();
  final assetPath = structManager.path;

  if (structManager.contains(type)) {
    throw StateError('`$type` already exists in `$assetPath`.');
  }

  print('Fetching documentation for `$type`...');
  final documentation = await WinRTDocsService.fetchDocumentation(type);
  print('Adding `$type` into `$assetPath`...');
  structManager.add(type, comment: documentation);
  print('Done!');
}

void main(List<String> args) async {
  final parser = ArgParser()
    ..addOption(
      'enum',
      abbr: 'e',
      help: 'WinRT enum type (e.g., Windows.Globalization.DayOfWeek).',
      valueHelp: 'type',
    )
    ..addOption(
      'object',
      abbr: 'o',
      help: 'WinRT object type (e.g., Windows.Storage.StorageFile).',
      valueHelp: 'type',
    )
    ..addOption(
      'struct',
      abbr: 's',
      help: 'WinRT struct type (e.g., Windows.Foundation.Point).',
      valueHelp: 'type',
    );

  try {
    final results = parser.parse(args);
    if (results.options.isEmpty) throw const FormatException();
    return switch (results.options.first) {
      'enum' => await addEnum(results.get('enum')),
      'object' => await addObject(results.get('object')),
      'struct' => await addStruct(results.get('struct')),
      _ => throw const FormatException(),
    };
  } on FormatException {
    print('Adds new WinRT APIs to be generated by winrtgen.\n');
    print('Usage: add_api [arguments]\n');
    print(parser.usage);
  }
}

extension on ArgResults {
  String get(String name) => this[name] as String;
}
